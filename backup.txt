const getUsers1 = async (user_status) => {
  const status = user_status ? { user_status } : {};
  return await User.find(status);
};

const signUpUserOld = async (userData,res) => {
//   const existingUser = await User.findOne({
//     mobile_number: userData.mobile_number,
//   });

//   if (existingUser) {
//     throw new Error("User already exists");
//   }

//   return await User.create(userData);

let user = await User.findOne({ mobile_number:userData.mobile_number });
console.log(":",user)
if (user) {
    if (user.user_status === "deleted") {
      throw new Error("This user is deleted. Please contact support.");
    }
    if (!user.verified) {
      user.user_name = userData.user_name;
      await user.save();
    } else {
      throw new Error("User is already registered and verified, please login");
    }
  } else {
    user = await User.create({
      user_name:userData.user_name,
      mobile_number:userData.mobile_number,
      verified: false,
    });
  }

  if (userData.mobile_number === "+919999999999") {
    return res.status(200).json({
        status: true,
        message: "User registered successfully. Use OTP 123456 to verify.",
    });
}

   if (lastOtpRequest[user._id] && Date.now() - lastOtpRequest[user._id] < 2 * 60 * 1000) {
    return res.status(400).json({
        status: false,
        message: "Please wait at least 2 minutes before requesting another OTP.",
    });
}

lastOtpRequest[user._id] = Date.now();

const otp = Math.floor(100000 + Math.random() * 900000);
const expiration = new Date(Date.now() + 2 * 60 * 1000); 

const countryCode = userData.mobile_number.slice(0, 3);
const phoneNumber = userData.mobile_number.slice(3);

await axios.post(interaktUrl, {
    countryCode: countryCode,
    phoneNumber: phoneNumber,
    callbackData: "OTP",
    type: "Template",
    template: {
        name: "doshion_app",
        languageCode: "en",
        bodyValues: [otp.toString()],
        buttonValues: {
            "0": [otp.toString()]
        }
    }
}, {
    headers: {
        Authorization: `Basic ${interaktApiKey}`,
        "Content-Type": "application/json"
    }
});

        // Save the OTP in the Otp collection
        const otpRecord = await Otp.create({
            userId: user._id,
            otp: otp.toString(),
            expiration: expiration,
        });

        setTimeout(async () => {
            await Otp.deleteOne({ _id: otpRecord._id });
            console.log("OTP expired and removed from database");
        }, 2 * 60 * 1000);
};

const signUpUserOld = async (userData,res) => {
//   const existingUser = await User.findOne({
//     mobile_number: userData.mobile_number,
//   });

//   if (existingUser) {
//     throw new Error("User already exists");
//   }

//   return await User.create(userData);

let user = await User.findOne({ mobile_number:userData.mobile_number });
console.log(":",user)
if (user) {
    if (user.user_status === "deleted") {
      throw new Error("This user is deleted. Please contact support.");
    }
    if (!user.verified) {
      user.user_name = userData.user_name;
      await user.save();
    } else {
      throw new Error("User is already registered and verified, please login");
    }
  } else {
    user = await User.create({
      user_name:userData.user_name,
      mobile_number:userData.mobile_number,
      verified: false,
    });
  }

  if (userData.mobile_number === "+919999999999") {
    return res.status(200).json({
        status: true,
        message: "User registered successfully. Use OTP 123456 to verify.",
    });
}

   if (lastOtpRequest[user._id] && Date.now() - lastOtpRequest[user._id] < 2 * 60 * 1000) {
    return res.status(400).json({
        status: false,
        message: "Please wait at least 2 minutes before requesting another OTP.",
    });
}

lastOtpRequest[user._id] = Date.now();

const otp = Math.floor(100000 + Math.random() * 900000);
const expiration = new Date(Date.now() + 2 * 60 * 1000); 

const countryCode = userData.mobile_number.slice(0, 3);
const phoneNumber = userData.mobile_number.slice(3);

await axios.post(interaktUrl, {
    countryCode: countryCode,
    phoneNumber: phoneNumber,
    callbackData: "OTP",
    type: "Template",
    template: {
        name: "doshion_app",
        languageCode: "en",
        bodyValues: [otp.toString()],
        buttonValues: {
            "0": [otp.toString()]
        }
    }
}, {
    headers: {
        Authorization: `Basic ${interaktApiKey}`,
        "Content-Type": "application/json"
    }
});

        // Save the OTP in the Otp collection
        const otpRecord = await Otp.create({
            userId: user._id,
            otp: otp.toString(),
            expiration: expiration,
        });

        setTimeout(async () => {
            await Otp.deleteOne({ _id: otpRecord._id });
            console.log("OTP expired and removed from database");
        }, 2 * 60 * 1000);
};

const signInUserold = async (mobile_number,res) => {
//   const user = await User.findOne({ mobile_number });
//   if (!user) {
//     throw new Error("User not found");
//   }
//   return user;

let user = await User.findOne({ mobile_number });

if (!user) {
    return res.status(404).json({
      status: false,
      message: "User not found",
    });
  }

  if (user.user_status === "deleted") {
    return res.status(400).json({
        status: false,
        message: "This user is deleted. Please contact support.",
    });
}

if (user.user_status !== "approve") {
    return res.status(400).json({
      status: false,
      message: "Your account has not been approved yet.",
    });
  }

  if (mobile_number === "+919999999999") {
    return res.status(200).json({
      status: true,
      message: "OTP sent to your mobile number. Use OTP 123456 to login.",
    });
  }

  if (
    lastOtpRequest[user._id] &&
    Date.now() - lastOtpRequest[user._id] < 2 * 60 * 1000
  ) {
    return res.status(400).json({
      status: false,
      message:
        "Please wait at least 2 minutes before requesting another OTP.",
    });
  }

  lastOtpRequest[user._id] = Date.now();

  // Generate a 6-digit OTP
  const otp = Math.floor(100000 + Math.random() * 900000);
  const expiration = new Date(Date.now() + 2 * 60 * 1000); // OTP expires in 2 minutes

  const countryCode = mobile_number.slice(0, 3);
  const phoneNumber = mobile_number.slice(3);

  await axios.post(
    interaktUrl,
    {
      countryCode: countryCode,
      phoneNumber: phoneNumber,
      callbackData: "OTP",
      type: "Template",
      template: {
        name: "doshion_app",
        languageCode: "en",
        bodyValues: [otp.toString()],
        buttonValues: {
          0: [otp.toString()],
        },
      },
    },
    {
      headers: {
        Authorization: `Basic ${interaktApiKey}`,
        "Content-Type": "application/json",
      },
    }
  );

  const otpRecord = await Otp.create({
    userId: user._id,
    otp: otp.toString(),
    expiration: expiration,
  });

  // Set a timeout to delete the OTP after 2 minutes
  setTimeout(async () => {
    await Otp.deleteOne({ _id: otpRecord._id });
    console.log("OTP expired and removed from database");
  }, 2 * 60 * 1000);
  
};

// await axios.post(
  //   interaktUrl,
  //   {
  //     countryCode: country_code,
  //     phoneNumber: mobile_number,
  //     callbackData: "OTP",
  //     type: "Template",
  //     template: { name: "doshion_app", languageCode: "en", bodyValues: [otp.toString()], buttonValues: { 0: [otp.toString()] } },
  //   },
  //   { headers: { Authorization: `Basic ${interaktApiKey}`, "Content-Type": "application/json" } }
  // );

  //old pattern
      .pattern(/^\d+\.\d+\.\d+\.[A-Za-z]{1,4}$/)

      const scanMultipleProductsOLd = async (Product_Codes,wareHouse_code) => {
    let messages = [];
    let success = false;
    const warehouse = await getwareHousesByCode(wareHouse_code);

    if(!warehouse)
    {
        return { success: false, message: `No WareHouse found for given code: ${wareHouse_code}`};
        // messages.push(`No WareHouse found for given code: ${wareHouse_code}`);
    }
    
    const Products = await ProductService.getMultipleProductByCode(Product_Codes);

    const foundProductCodes = Products.map((p) => p.productCode);

    const missingProductCodes = Product_Codes.filter(code => !foundProductCodes.includes(code));

    if (missingProductCodes.length > 0) {
        // return { success: false, message: `No products found for given code ${missingProductCodes.join(", ")}` };
        messages.push(`No products found for given codes : ${missingProductCodes.join(", ")}`);
    }

    //extract products
    const exhaustedProducts = Products.filter((p) => p.productStatus === ProductEnum.EXHAUSTED && p.isActive);
    console.log("ex:",exhaustedProducts);

    const newProducts = Products.filter((p) => p.productStatus === ProductEnum.NEW && p.isActive);
    console.log("N:",newProducts);

    const inUseProducts = Products.filter((p) => p.productStatus === ProductEnum.IN_USE && p.isActive);
    console.log("in:",inUseProducts);

    const deletedProducts = Products.filter((p) => !p.isActive);
    console.log("del:",deletedProducts);

    //extract productcodes
    const exhaustedCodes = exhaustedProducts.map((ep) => ep.productCode).join(", ");
    const newCodes = newProducts.map((np) => np.productCode).join(", ");
    const inUseCodes = inUseProducts.map((ip) => ip.productCode).join(", ");
    const deletedCode = deletedProducts.map((dp) => dp.productCode).join(", ");

    

    if(newProducts.length > 0)
    {
        messages.push(`Product status already NEW for: ${newCodes}`);
    }

    if(deletedProducts.length > 0)
    {
        messages.push(`Product Is Not Active for: ${deletedCode}`);
    }    

    if(inUseProducts.length > 0)
    {
        messages.push(`Product status InUse for: ${inUseCodes}`);
    }   

    if (exhaustedProducts.length > 0 && missingProductCodes.length === 0 && newCodes.length === 0 && inUseCodes.length === 0 && deletedCode.length === 0)
    {
        const exhaustedProductIds = exhaustedProducts.map((product) => product._id);

        await Product.updateMany(
            {_id: {$in:exhaustedProductIds} },
            {$set:{productStatus:ProductEnum.NEW,isActive:true}}
        )

        messages.push(`Product status updated to NEW for: ${exhaustedCodes}`);
        success=true;
    }

    return {
        success,
        message:messages,
        ProductCodes: {
            notFound: missingProductCodes,
            alreadyNew: newCodes, 
            inUse:inUseCodes,
            deleted: deletedCode, 
        },
        data: exhaustedProducts, 
    };
};

const mongoose = require("mongoose");
const { ProductEnum } = require('../config/global.js');

const ProductSchema = new mongoose.Schema(
  {
    // productName: { type: String, required: true },
    productCode: {
      type: String,
      required: true,
      unique: true,
      // validate: {
      //   validator: function (value) {
      //     // return /^[A-Za-z]{4}\d{4}$/.test(value); 
      //     return /^\d{3,4}\.\d{1,2}\.\d{2}\.[A-Za-z]{1,4}$/.test(value);
      //   },
      //   // message: "Product code must have 4 letters followed by 4 digits (e.g., ABCD1234)",
      //   message:"Product code must follow the format: 0000.00.00.ABCD Upto"
      // },
    },
    // productDesc: String,
    // connectorType :String,
    distributorType :String,
    // size:String,
    isActive: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now },
    resinType:{type: String},
    vesselSize:{type: String},
    adapterSize:{type:String},
    productStatus: { type: String, enum: [ProductEnum.NEW, ProductEnum.EXHAUSTED, ProductEnum.IN_USE], required: true, default: ProductEnum.NEW},
  },
  { timestamps: true }
);

module.exports = mongoose.model("Product", ProductSchema);

//cluster assigns

        const currentDate = new Date();
        const indianDate = new Date(currentDate.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
        indianDate.setHours(0, 0, 0, 0);

                // Convert date to Indian timezone for consistent comparison
        const assignmentDate = new Date(date);
        const indianDate = new Date(assignmentDate.toLocaleString('en-US', { timeZone: 'Asia/Kolkata' }));
        indianDate.setHours(0, 0, 0, 0);

// cluster service

// old code
// const getClusteredCustomerLocationsold = async (
//   maxCustomersPerCluster = 15,
//   maxCartridgeQty = 20
// ) => {
//   try {
//     const { data: customersRaw } = await getGeoLocations();

//     const customers = customersRaw.map((item) => ({
//       _id: item.customer.id, // map `id` to `_id`
//       display_name: item.customer.name,
//       contact_number: item.customer.contact_number,
//       cf_cartridge_qty: item.customer.cf_cartridge_qty,
//       geoCoordinates: item.mainGeoCoordinates,
//     }));

//     console.log("customers", customers);

//     const allClusters = await Cluster.find({}).lean();

//     // Track existing customer IDs in clusters
//     const clusteredIds = new Set(
//   allClusters.flatMap((c) =>
//     c.customers.map((cObj) => cObj.customerId.toString())
//   )
// );


//     // Track current state of each cluster
//     const existingClusterUsage = {};
//     let numClusters = allClusters.length || 6;

//     for (let i = 0; i < numClusters; i++) {
//       const clusterData = allClusters.find((c) => c.clusterNo === i);
//       existingClusterUsage[i] = {
//         customers: clusterData
//           ? [...clusterData.customers.map((c) => c.toString())]
//           : [],
//         totalCartridge: clusterData ? clusterData.cartridge_qty || 0 : 0,
//       };
//     }

//     // Filter only new customers not yet in any cluster
//     const newCustomers = customers.filter(
//       (cust) =>
//         cust.geoCoordinates &&
//         Array.isArray(cust.geoCoordinates.coordinates) &&
//         cust.geoCoordinates.coordinates.length === 2 &&
//         !clusteredIds.has(cust._id.toString())
//     );

//     if (newCustomers.length === 0) {
//       throw new Error("No new customers found");
//     }

//     const coordinates = newCustomers.map((c) => c.geoCoordinates.coordinates);
//     // const numClusters = 2;

//     // Step 2: Initialize centroids from first N new customers
//     let centroids = coordinates.slice(0, numClusters);
//     let assignments = new Array(coordinates.length).fill(-1);
//     let changed = true;
//     let iterations = 0;
//     const MAX_ITER = 100;

//     while (changed && iterations < MAX_ITER) {
//       changed = false;
//       iterations++;

//       for (let i = 0; i < coordinates.length; i++) {
//         const distances = centroids.map((c) => distance(coordinates[i], c));
//         const nearestCentroid = distances.indexOf(Math.min(...distances));
//         if (assignments[i] !== nearestCentroid) {
//           assignments[i] = nearestCentroid;
//           changed = true;
//         }
//       }

//       const newCentroids = new Array(numClusters).fill(0).map(() => [0, 0]);
//       const counts = new Array(numClusters).fill(0);

//       for (let i = 0; i < coordinates.length; i++) {
//         const cluster = assignments[i];
//         newCentroids[cluster][0] += coordinates[i][0];
//         newCentroids[cluster][1] += coordinates[i][1];
//         counts[cluster]++;
//       }

//       for (let j = 0; j < numClusters; j++) {
//         if (counts[j] > 0) {
//           newCentroids[j][0] /= counts[j];
//           newCentroids[j][1] /= counts[j];
//         }
//       }

//       centroids = newCentroids;
//     }

//     // Step 3: Assign customers based on closest available cluster
//     const assignedCustomers = [];

//     for (let i = 0; i < newCustomers.length; i++) {
//       const cust = newCustomers[i];
//       const coord = coordinates[i];
//       const cartridge = parseFloat(cust.cf_cartridge_qty) || 0;

//       const distances = centroids.map((c) => distance(coord, c));
//       const sortedClusters = distances
//         .map((d, idx) => ({ cluster: idx, dist: d }))
//         .sort((a, b) => a.dist - b.dist);

//       let assigned = false;

//       for (const { cluster } of sortedClusters) {
//         const usage = existingClusterUsage[cluster];
//         if (
//           usage.customers.length < maxCustomersPerCluster &&
//           usage.totalCartridge + cartridge <= maxCartridgeQty
//         ) {
//           usage.customers.push(cust._id.toString());
//           usage.totalCartridge += cartridge;
//           assignedCustomers.push({ ...cust, cluster });
//           assigned = true;
//           break;
//         }
//       }

//       if (!assigned) {
//         // Create new cluster dynamically
//         const newClusterNo = numClusters++;
//         existingClusterUsage[newClusterNo] = {
//           customers: [cust._id.toString()],
//           totalCartridge: cartridge,
//         };
//         centroids.push(coord); // Add centroid for new cluster
//         assignedCustomers.push({ ...cust, cluster: newClusterNo });
//         console.log(
//           `Created new cluster ${newClusterNo} for customer ${cust._id}`
//         );
//       }
//     }

//     for (let clusterNo in existingClusterUsage) {
//       clusterNo = parseInt(clusterNo);
//       const usage = existingClusterUsage[clusterNo];
//       const clusterData = allClusters.find((c) => c.clusterNo === clusterNo);

//       if (clusterData) {
// clusterData.customers = usage.customers.map((id, index) => ({
//   customerId: id,
// }));

//         clusterData.cartridge_qty = usage.totalCartridge;
//         await Cluster.findByIdAndUpdate(clusterData._id, clusterData);
//       } else {
//         await Cluster.create({
//           clusterNo,
//           customers: usage.customers.map((id, index) => ({
//     customerId: id,
//   })),
//           cartridge_qty: usage.totalCartridge,
//         });
//       }
//     }

//     return assignedCustomers;
//   } catch (error) {
//     console.error("Clustering Error:", error);
//     throw new Error(error.message);
//   }
// };

// const getAllClustersold = async () => {
//   try {
//     const clusters = await Cluster.aggregate([
//       {
//         $lookup: {
//           from: "customers",
//           localField: "customers",
//           foreignField: "_id",
//           as: "customers",
//         },
//       },
//       {
//         $lookup: {
//           from: "geolocations",
//           let: { customerId: "$customers._id" },
//           pipeline: [
//             {
//               $match: {
//                 $expr: {
//                   $in: ["$customerId", "$$customerId"],
//                 },
//               },
//             },
//             {
//               $group: {
//                 _id: "$customerId",
//                 geoCoordinates: { $first: "$MaingeoCoordinates" },
//               },
//             },
//           ],
//           as: "geoData",
//         },
//       },
//       {
//         $addFields: {
//           customers: {
//             $map: {
//               input: "$customers",
//               as: "cust",
//               in: {
//                 _id: "$$cust._id",
//                 display_name: "$$cust.display_name",
//                 contact_number: "$$cust.contact_number",
//                 MaingeoCoordinates: "$$cust.MaingeoCoordinates",
//                 geoCoordinates: {
//                   $let: {
//                     vars: {
//                       geo: {
//                         $arrayElemAt: [
//                           {
//                             $filter: {
//                               input: "$geoData",
//                               as: "g",
//                               cond: { $eq: ["$$g._id", "$$cust._id"] },
//                             },
//                           },
//                           0,
//                         ],
//                       },
//                     },
//                     in: "$$geo.geoCoordinates",
//                   },
//                 },
//               },
//             },
//           },
//         },
//       },
//       {
//         $project: {
//           clusterNo: 1,
//           cartridge_qty: 1,
//           customers: 1,
//         },
//       },
//     ]);

//     return clusters;
//   } catch (error) {
//     throw new Error("Failed to fetch clusters: " + error.message);
//   }
// };

// function haversineDistance(coord1, coord2) {
//   const toRad = (deg) => (deg * Math.PI) / 180;
//   const R = 6371;
//   const dLat = toRad(coord2.lat - coord1.lat);
//   const dLon = toRad(coord2.lng - coord1.lng);
//   const lat1 = toRad(coord1.lat);
//   const lat2 = toRad(coord2.lat);
//   const a =
//     Math.sin(dLat / 2) ** 2 +
//     Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
//   const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
//   return R * c;
// }

// function optimizeRoute(cluster, warehouse) {
//   const customers = cluster.customers
//     .filter((c) => c.geoCoordinates && Array.isArray(c.geoCoordinates.coordinates))
//     .map((c) => ({
//       customerId: c.customerId?._id?.toString?.() || c.customerId.toString?.(), // FIXED
//       name: c.name,
//       coord: {
//         lat: c.geoCoordinates.coordinates[1],
//         lng: c.geoCoordinates.coordinates[0],
//       },
//     }));

//   let currentLocation = warehouse;
//   const route = [];
//   const unvisited = new Set(customers);

//   while (unvisited.size > 0) {
//     let nearest = null;
//     let nearestDist = Infinity;

//     for (const customer of unvisited) {
//       const dist = haversineDistance(currentLocation, customer.coord);
//       if (dist < nearestDist) {
//         nearestDist = dist;
//         nearest = customer;
//       }
//     }

//     route.push(nearest);
//     currentLocation = nearest.coord;
//     unvisited.delete(nearest);
//   }

//   return route;
// }

// function optimizeRouteold(cluster, warehouse) {
//   const customers = cluster.customers
//     .filter(
//       (c) => c.geoCoordinates && Array.isArray(c.geoCoordinates.coordinates)
//     )
//     .map((c) => ({
//       id: c._id,
//       name: c.display_name,
//       coord: {
//         lat: c.geoCoordinates.coordinates[1],
//         lng: c.geoCoordinates.coordinates[0],
//       },
//     }));

//   let currentLocation = warehouse;
//   const route = [];
//   const unvisited = new Set(customers);

//   while (unvisited.size > 0) {
//     let nearest = null;
//     let nearestDist = Infinity;

//     for (const customer of unvisited) {
//       const dist = haversineDistance(currentLocation, customer.coord);
//       if (dist < nearestDist) {
//         nearestDist = dist;
//         nearest = customer;
//       }
//     }

//     route.push(nearest);
//     currentLocation = nearest.coord;
//     unvisited.delete(nearest);
//   }

//   return route;
// }

// const fetchOptimizedRoutesold = async (clusterNo) => {
//   console.log("No:",clusterNo);
//   let clusters = await getAllClusters();
//   console.log(clusters);
  

//   if(clusterNo !== undefined && clusterNo !== null && !isNaN(clusterNo))
//   {
//     clusters = clusters.filter((cluster) => cluster.clusterNo === clusterNo);
//   }

//   console.log("cluster:",clusters);
  

//   const results = [];

//   for (const cluster of clusters) {
//     const optimizedRoute = optimizeRoute(cluster, warehouseLocation);
//     const visitSequence = [];

//     let totalDistance = 0;
//     let lastCoord = warehouseLocation;

//     // Start from warehouse
//     visitSequence.push({
//       visitNumber: 0,
//       customerName: "Warehouse",
//       lat: warehouseLocation.lat,
//       lng: warehouseLocation.lng,
//       clusterId: cluster.clusterNo,
//       distanceFromPrev: 0,
//     });

//     // Update sequenceNo in original structure (customerId + sequenceNo)
//     const updatedCustomers = [];

//     optimizedRoute.forEach((customer, idx) => {
//       const dist = haversineDistance(lastCoord, customer.coord);
//       totalDistance += dist;

//       const visitNumber = idx + 1;

//       visitSequence.push({
//         visitNumber,
//         customerName: customer.name,
//         lat: customer.coord.lat,
//         lng: customer.coord.lng,
//         clusterId: cluster.clusterNo,
//         distanceFromPrev: dist,
//       });

//       // Store updated structure
//      updatedCustomers.push({
//   customerId: new mongoose.Types.ObjectId(customer.customerId), // ✅ FIXED
//   sequenceNo: visitNumber,
// });


//       lastCoord = customer.coord;
//     });

//     // Return to warehouse
//     const returnDist = haversineDistance(lastCoord, warehouseLocation);
//     totalDistance += returnDist;

//     visitSequence.push({
//       visitNumber: optimizedRoute.length + 1,
//       customerName: "Return to Warehouse",
//       lat: warehouseLocation.lat,
//       lng: warehouseLocation.lng,
//       clusterId: cluster.clusterNo,
//       distanceFromPrev: returnDist,
//     });

//     // Save updated customers to DB
//     const newQty = cluster.customers.reduce(
//   (sum, c) => sum + (parseFloat(c.cf_cartridge_qty) || 0),
//   0
// );
// await Cluster.updateOne(
//   { _id: cluster._id },
//   { $set: { customers: updatedCustomers, cartridge_qty: newQty } }
// );


//     results.push({
//       clusterNo: cluster.clusterNo,
//       cartridge_qty: cluster.cartridge_qty,
//       totalDistance: totalDistance.toFixed(2),
//       visitSequence,
//     });
//   }

//   return results;
// };

// const reassignMultipleCustomersToClustersold = async (reassignments) => {
//   const session = await mongoose.startSession();
//   session.startTransaction();

//   try {
//     const MAX_CUSTOMERS = 20;
//     const MAX_CARTRIDGES = 24;

//     // Step 1: Fetch all customers involved
//     const customerIds = reassignments.map((r) => r.customerId);
//     const customers = await Customer.find({ _id: { $in: customerIds } })
//       .session(session)
//       .lean();
//     const customerMap = new Map(customers.map((c) => [c._id.toString(), c]));

//     // Step 2: Remove customers from any existing clusters and adjust cartridge qty
//     for (const { customerId } of reassignments) {
//       const customer = customerMap.get(customerId);
//       const cartridgeQty = parseFloat(customer.cf_cartridge_qty) || 0;

//       // Remove from any cluster where the customer exists
//       const clustersWithCustomer = await Cluster.find({
//   "customers.customerId": customerId,
// }).session(session);


//       for (const cluster of clustersWithCustomer) {
//       cluster.customers = cluster.customers.filter(
//   (c) => c.customerId.toString() !== customerId.toString()
// );

//         cluster.cartridge_qty = Math.max(
//           0,
//           (cluster.cartridge_qty || 0) - cartridgeQty
//         );
//         await cluster.save({ session });
//       }
//     }

//     // Step 3: Prepare new assignments grouped by cluster
//     const clusterMap = {};
//     for (const { customerId, newClusterNo } of reassignments) {
//       if (!clusterMap[newClusterNo]) clusterMap[newClusterNo] = [];
//       clusterMap[newClusterNo].push(customerId);
//     }

//     // Step 4: Assign to new clusters with validations
//     for (const [clusterNoStr, customerIds] of Object.entries(clusterMap)) {
//       const clusterNo = Number(clusterNoStr);
//       const customerObjs = customerIds.map((id) => customerMap.get(id));
//       const totalNewCartridges = customerObjs.reduce(
//         (sum, c) => sum + (parseFloat(c.cf_cartridge_qty) || 0),
//         0
//       );

//       let cluster = await Cluster.findOne({ clusterNo }).session(session);

//       const currentCustomerCount = cluster ? cluster.customers.length : 0;
//       const currentCartridgeQty = cluster ? cluster.cartridge_qty || 0 : 0;

//       if (currentCustomerCount + customerIds.length > MAX_CUSTOMERS) {
//         throw new Error(`Cluster ${clusterNo} would exceed customer limit`);
//       }

//       if (currentCartridgeQty + totalNewCartridges > MAX_CARTRIDGES) {
//         throw new Error(`Cluster ${clusterNo} would exceed cartridge limit`);
//       }

//       if (cluster) {
//         cluster.customers.push(...customerIds.map(id => ({ customerId: id }))); // ✅
//         cluster.cartridge_qty += totalNewCartridges;
//         await cluster.save({ session });
//       } else {
//         await Cluster.create(
//           [
//             {
//               clusterNo,
//               customers: customerIds.map(id => ({ customerId: id })),
//               cartridge_qty: totalNewCartridges,
//             },
//           ],
//           { session }
//         );
//       }
//     }

//     await session.commitTransaction();
//     session.endSession();
//   } catch (error) {
//     await session.abortTransaction();
//     session.endSession();
//     throw new Error(error.message);
//   }
// };

// const reassignMultipleCustomersToClusters1 = async (reassignments) => {
//   const session = await mongoose.startSession();
//   session.startTransaction();

//   try {
//     const MAX_CUSTOMERS = 20;
//     const MAX_CARTRIDGES = 24;

//     // Step 1: Fetch all involved customers
//     const customerIds = reassignments.map((r) => r.customerId);
//     const customers = await Customer.find({ _id: { $in: customerIds } })
//       .session(session)
//       .lean();

//     // Step 2: Map customers by stringified _id
//     const customerMap = new Map(customers.map((c) => [c._id.toString(), c]));
//     console.log("Loaded customerMap:", [...customerMap.keys()]);

//     // Step 3: Remove customers from their old clusters
//     for (const { customerId } of reassignments) {
//       console.log("reassignments",reassignments);
      
//       const customerKey = customerId.toString();
//       const customer = customerMap.get(customerKey);

//       if (!customer) {
//         throw new Error(`Customer with ID ${customerId} not found in DB`);
//       }

//       const cartridgeQty = parseFloat(customer.cf_cartridge_qty) || 0;

//       const clustersWithCustomer = await Cluster.find({
//         "customers.customerId": customerId,
//       }).session(session);

//       for (const cluster of clustersWithCustomer) {
//         cluster.customers = cluster.customers.filter(
//           (c) => c.customerId.toString() !== customerId.toString()
//         );
//         cluster.cartridge_qty = Math.max(
//           0,
//           (cluster.cartridge_qty || 0) - cartridgeQty
//         );
//         await cluster.save({ session });
//       }
//     }

//     // Step 4: Group reassigned customers by newClusterNo
//     const clusterMap = {};
//     for (const { customerId, newClusterNo } of reassignments) {
//       if (!clusterMap[newClusterNo]) clusterMap[newClusterNo] = [];
//       clusterMap[newClusterNo].push(customerId.toString());
//     }

//     // Step 5: Add customers to their new clusters
//     for (const [clusterNoStr, customerIds] of Object.entries(clusterMap)) {
//       const clusterNo = Number(clusterNoStr);
//       const customerObjs = customerIds.map((id) => customerMap.get(id));

//       const totalNewCartridges = customerObjs.reduce(
//         (sum, c) => sum + (parseFloat(c?.cf_cartridge_qty) || 0),
//         0
//       );

//       let cluster = await Cluster.findOne({ clusterNo }).session(session);

//       const currentCustomerCount = cluster ? cluster.customers.length : 0;
//       const currentCartridgeQty = cluster ? cluster.cartridge_qty || 0 : 0;

//       if (currentCustomerCount + customerIds.length > MAX_CUSTOMERS) {
//         throw new Error(`Cluster ${clusterNo} would exceed customer limit`);
//       }

//       if (currentCartridgeQty + totalNewCartridges > MAX_CARTRIDGES) {
//         throw new Error(`Cluster ${clusterNo} would exceed cartridge limit`);
//       }

//       const newCustomerObjects = customerIds.map((id, idx) => ({
//         customerId: new mongoose.Types.ObjectId(id),
//         sequenceNo: currentCustomerCount + idx + 1,
//       }));

//       if (cluster) {
//         cluster.customers.push(...newCustomerObjects);
//         cluster.cartridge_qty += totalNewCartridges;
//         await cluster.save({ session });
//       } else {
//         await Cluster.create(
//           [
//             {
//               clusterNo,
//               customers: newCustomerObjects,
//               cartridge_qty: totalNewCartridges,
//             },
//           ],
//           { session }
//         );
//       }
//     }

//     await session.commitTransaction();
//     session.endSession();
//   } catch (error) {
//     await session.abortTransaction();
//     session.endSession();
//     throw new Error(error.message);
//   }
// };

// const getClusteredCustomerLocations = async () => {
//   try {
//     const { data: customersRaw } = await getGeoLocations();

//     const customers = customersRaw.map((item) => ({
//       _id: item.customer.id,
//       display_name: item.customer.name,
//       contact_number: item.customer.contact_number,
//       cf_cartridge_qty: item.customer.cf_cartridge_qty,
//       geoCoordinates: item.mainGeoCoordinates,
//     }));

//     const allClusters = await Cluster.find({}).lean();

//     const clusteredIds = new Set(
//       allClusters.flatMap((c) =>
//         c.customers.map((cObj) => cObj.customerId?.toString())
//       )
//     );

//     const existingClusterUsage = {};
//     let numClusters = allClusters.length || 6;

//     for (let i = 0; i < numClusters; i++) {
//       const clusterData = allClusters.find((c) => c.clusterNo === i);
//       existingClusterUsage[i] = {
//         customers: clusterData
//           ? [...clusterData.customers.map((c) => c.customerId?.toString())]
//           : [],
//         totalCartridge: clusterData ? clusterData.cartridge_qty || 0 : 0,
//       };
//     }

//     const newCustomers = customers.filter(
//       (cust) =>
//         cust.geoCoordinates &&
//         Array.isArray(cust.geoCoordinates.coordinates) &&
//         cust.geoCoordinates.coordinates.length === 2 &&
//         !clusteredIds.has(cust._id.toString())
//     );

//     if (newCustomers.length === 0) {
//       throw new Error("No new customers found");
//     }

//     const coordinates = newCustomers.map((c) => c.geoCoordinates.coordinates);
//     let centroids = coordinates.slice(0, numClusters);
//     let assignments = new Array(coordinates.length).fill(-1);
//     let changed = true;
//     let iterations = 0;
//     const MAX_ITER = 100;

//     while (changed && iterations < MAX_ITER) {
//       changed = false;
//       iterations++;

//       for (let i = 0; i < coordinates.length; i++) {
//         const distances = centroids.map((c) => distance(coordinates[i], c));
//         const nearestCentroid = distances.indexOf(Math.min(...distances));
//         if (assignments[i] !== nearestCentroid) {
//           assignments[i] = nearestCentroid;
//           changed = true;
//         }
//       }

//       const newCentroids = new Array(numClusters).fill(0).map(() => [0, 0]);
//       const counts = new Array(numClusters).fill(0);

//       for (let i = 0; i < coordinates.length; i++) {
//         const cluster = assignments[i];
//         newCentroids[cluster][0] += coordinates[i][0];
//         newCentroids[cluster][1] += coordinates[i][1];
//         counts[cluster]++;
//       }

//       for (let j = 0; j < numClusters; j++) {
//         if (counts[j] > 0) {
//           newCentroids[j][0] /= counts[j];
//           newCentroids[j][1] /= counts[j];
//         }
//       }

//       centroids = newCentroids;
//     }

//     const assignedCustomers = [];

//     for (let i = 0; i < newCustomers.length; i++) {
//       const cust = newCustomers[i];
//       const coord = coordinates[i];
//       const cartridge = parseFloat(cust.cf_cartridge_qty) || 0;

//       const distances = centroids.map((c) => distance(coord, c));
//       const sortedClusters = distances
//         .map((d, idx) => ({ cluster: idx, dist: d }))
//         .sort((a, b) => a.dist - b.dist);

//       let assigned = false;

//       for (const { cluster } of sortedClusters) {
//         const usage = existingClusterUsage[cluster];
//         if (usage.customers.length === 0) {
//           usage.customers.push(cust._id.toString());
//           usage.totalCartridge = cartridge;
//           assignedCustomers.push({ ...cust, cluster });
//           assigned = true;
//           break;
//         }
//       }

//       if (!assigned) {
//         // Assign to Cluster 7 if all full
//         const cluster7 = existingClusterUsage[7] || { customers: [], totalCartridge: 0 };
//         cluster7.customers.push(cust._id.toString());
//         cluster7.totalCartridge += cartridge;
//         existingClusterUsage[7] = cluster7;
//         assignedCustomers.push({ ...cust, cluster: 7 });
//       }
//     }

//     // Write back to DB
//     for (let clusterNo in existingClusterUsage) {
//       clusterNo = parseInt(clusterNo);
//       const usage = existingClusterUsage[clusterNo];

//       const formattedCustomers = usage.customers.map((id, index) => ({
//         customerId: new mongoose.Types.ObjectId(id),
//         sequenceNo: index + 1,
//       }));

//       const existing = await Cluster.findOne({ clusterNo });

//       if (existing) {
//         await Cluster.updateOne(
//           { clusterNo },
//           {
//             $set: {
//               customers: formattedCustomers,
//               cartridge_qty: usage.totalCartridge,
//             },
//           }
//         );
//       } else {
//         await Cluster.create({
//           clusterNo,
//           customers: formattedCustomers,
//           cartridge_qty: usage.totalCartridge,
//         });
//       }
//     }

//     return assignedCustomers;
//   } catch (error) {
//     console.error("Clustering Error:", error);
//     throw new Error(error.message);
//   }
// };


// const reassignMultipleCustomersToClusters = async (reassignments) => {
//   const session = await mongoose.startSession();
//   session.startTransaction();

//   try {
//     const customerIds = reassignments.map((r) => r.customerId);
//     const customers = await Customer.find({ _id: { $in: customerIds } }).session(session).lean();
//     const customerMap = new Map(customers.map((c) => [c._id.toString(), c]));

//     // 1. Remove from all clusters
//     await Cluster.updateMany(
//       { "customers.customerId": { $in: customerIds.map(id => new mongoose.Types.ObjectId(id)) } },
//       {
//         $pull: {
//           customers: {
//             customerId: { $in: customerIds.map(id => new mongoose.Types.ObjectId(id)) }
//           }
//         }
//       },
//       { session }
//     );

//     // 2. Recalculate cartridge_qty for all clusters after removal
//     const allClusters = await Cluster.find().session(session);
//     for (const cluster of allClusters) {
//       const updatedCustomerIds = cluster.customers.map(c => c.customerId.toString());
//       const updatedQty = updatedCustomerIds.reduce((sum, id) => {
//         const c = customerMap.get(id);
//         return sum + (parseFloat(c?.cf_cartridge_qty) || 0);
//       }, 0);
//       cluster.cartridge_qty = updatedQty;
//       await cluster.save({ session });
//     }

//     // 3. Assign to new clusters
//     const groupedByCluster = {};

//     for (const { customerId, newClusterNo } of reassignments) {
//       if (!groupedByCluster[newClusterNo]) groupedByCluster[newClusterNo] = [];
//       groupedByCluster[newClusterNo].push(customerId);
//     }

//     for (const [clusterNoStr, ids] of Object.entries(groupedByCluster)) {
//       const clusterNo = parseInt(clusterNoStr);
//       const cluster = await Cluster.findOne({ clusterNo }).session(session);

//       const existingCustomers = cluster?.customers || [];
//       const startSequence = existingCustomers.length;

//       const newCustomerObjs = ids.map((id, index) => ({
//         customerId: new mongoose.Types.ObjectId(id),
//         sequenceNo: startSequence + index + 1,
//       }));

//       const newCartridgeQty = ids.reduce((sum, id) => {
//         const c = customerMap.get(id);
//         return sum + (parseFloat(c?.cf_cartridge_qty) || 0);
//       }, 0);

//       if (cluster) {
//         cluster.customers.push(...newCustomerObjs);
//         cluster.cartridge_qty += newCartridgeQty;
//         await cluster.save({ session });
//       } else {
//         await Cluster.create(
//           [
//             {
//               clusterNo,
//               customers: newCustomerObjs,
//               cartridge_qty: newCartridgeQty,
//             },
//           ],
//           { session }
//         );
//       }
//     }

//     await session.commitTransaction();
//     session.endSession();
//   } catch (err) {
//     await session.abortTransaction();
//     session.endSession();
//     throw new Error("Reassignment failed: " + err.message);
//   }
// };

meet 